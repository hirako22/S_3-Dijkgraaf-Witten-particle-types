import os
import string

d_4 = ["1", "r", "a", "aa", "aaa", "ra", "raa", "raaa"]

def parseElement(d4_string):
  permuted = [1, 2, 3, 4]
  for letter in reversed(d4_string):
    if letter == 'a':
      permuted = [permuted[3], permuted[0], permuted[1], permuted[2]]
    elif letter == 'r':
      permuted = [permuted[1], permuted[0], permuted[3], permuted[2]]
    elif letter == '1':
      pass
    else:
      print("Invalid D_4 element: "+str(letter))
      break
  if permuted == [1, 2, 3, 4]:
    return "1"
  elif permuted == [2, 1, 4, 3]:
    return "r"
  elif permuted == [4, 1, 2, 3]:
    return "a"
  elif permuted == [3, 4, 1, 2]:
    return "aa"
  elif permuted == [2, 3, 4, 1]:
    return "aaa"
  elif permuted == [1, 4, 3, 2]:
    return "ra"
  elif permuted == [4, 3, 2, 1]:
    return "raa"
  else:
    return "raaa"

def inverse(element):
  if element == "1":
    return "1"
  elif element == "r":
    return "r"
  elif element == "a":
    return "aaa"
  elif element == "aa":
    return "aa"
  elif element == "aaa":
    return "a"
  elif element == "ra":
    return "ra"
  elif element == "raa":
    return "raa"
  elif element == "raaa":
    return "raaa"
  else:
    print(str(element)+" is not a suitable element to take inverse of.")
    return "/"

def checkQuotients(gens, code, qArray):
  gen_list = gens.split(",")
  code_list = code.split(",")
  if len(gen_list) != len(code_list):
    # this shouldn't come up
    print("Code is not the same length as the generators.")
    return False
  dictionary = {}
  for i in range(0,len(gen_list)):
    dictionary.update({gen_list[i]: code_list[i]})
  # checks if all the quotients work out
  for quotient in qArray:
    quotient_list = quotient.split(",")
    translatedQuotient = ""
    # write quotients in terms of elements of D_4
    for q in quotient_list: # element in quotient
      if q[-1] == '*':
        translatedQuotient = translatedQuotient + inverse(dictionary[q[:-1]])
      else:
        translatedQuotient = translatedQuotient + dictionary[q]
    if parseElement(translatedQuotient) != "1":
      return False
  return True

def addHomomorphisms(code_set, prefix, k, genString, quotientArray):
  if k == 0:
    if checkQuotients(genString, prefix, quotientArray):
      code_set.append(prefix)
    return
  for element in d_4:
    newPrefix = prefix + "," + element
    if prefix == "":
      newPrefix = element
    addHomomorphisms(code_set, newPrefix, k-1, genString, quotientArray)

def conjugate(word, el):
  word_list = word.split(",")
  conjugated = []
  for c in word_list:
    conjugated.append(parseElement(el + c + inverse(el)))
  return ",".join(conjugated)

def checkConjugate(codeSet, newCode):
  if newCode in codeSet:
    return False
  for element in d_4[1:]:
    conjugated = conjugate(newCode, element)
    if conjugated in codeSet:
        return True
  return False

def computeLBB(gens, code, l):
  gen_list = gens.split(",")
  code_list = code.split(",")
  l_list = l.split(",")
  if len(gen_list) != len(code_list):
    # this shouldn't come up
    print("Code is not the same length as the generators.")
    return False
  dictionary = {}
  for i in range(0,len(gen_list)):
    dictionary.update({gen_list[i]: code_list[i]})
  # map l_bb word via homomorphism into d_4
  l_d4 = ""
  for l_letter in l_list:
    if l_letter[-1] == '*':
      l_d4 = l_d4 + inverse(dictionary[l_letter[:-1]])
    else:
      l_d4 = l_d4 + dictionary[l_letter]
  return parseElement(l_d4)

def computeCenter(m, l):
  commuters = ["1"]
  for element in d_4[1:]:
    conjugate_m = parseElement(element + m + inverse(element))
    conjugate_l = parseElement(element + l + inverse(element))
    if conjugate_m == m and conjugate_l == l:
      commuters.append(element)
  return commuters

def particleTypes(generators, quotientsArray, lBB):
  homomorphismSet = []
  # create all associations of generators with elements in d_4
  addHomomorphisms(homomorphismSet, "", len(generators.split(",")), generators, quotientsArray)
  homModConjugation = {}
  homCenter = {}
  # compute l, mod out (m, l) set by conjugation
  for codeCand in homomorphismSet:
    blackboardMeridian = computeLBB(generators, codeCand, lBB)
    pair = codeCand.split(",")[0] + "," + blackboardMeridian
    if not checkConjugate(homModConjugation.values(), pair):
      homModConjugation[codeCand] = pair
      center = computeCenter(codeCand.split(",")[0], blackboardMeridian)
      homCenter[pair] = center
  particleTypes = set([])
  # pair (m, l) with representations, take direct sums if need be
  for hom in homModConjugation.keys():
    pair = homModConjugation[hom]
    if len(homCenter[pair]) > 1:
      element = homCenter[pair][1]
      homConjugated = conjugate(hom, element)
      # the only nontrivial proper subgroups of d_4 are Z_2, Z_4, and the Klein 4-group
      if homConjugated != hom:
        # Z_2
        if conjugate(homConjugated, element) == hom and len(homCenter[pair]) == 2:
          particleTypes.add("[("+pair+"), trivial]"+u'\u2295'+"[("+pair+"), sign]")
        # Klein
        elif conjugate(homConjugated, element) == hom and len(homCenter[pair]) == 4:
          particleTypes.add("[("+pair+"), trivial]"+u'\u2295'+"[("+pair+"), (1, -1)]")
        # Z_4
        else:
          particleTypes.add("[("+pair+"), trivial]"+u'\u2295'+"[("+pair+"), w]"+u'\u2295'+"[("+pair+"), w^2]"+u'\u2295'+"[("+pair+"), w^3]")
      # account for if the trivial subgroup is the center of (m, l)
      else:
        particleTypes.add("[("+pair+"), trivial]")
    else: # if the center of the homomorphism is the trivial group
      particleTypes.add("[("+pair+"), trivial]")
  return particleTypes

os.system('clear')
print("\n")
print("\t*************************************************************")
print("\t**    D_4 Dijkgraaf-Witten particle types on a manifold    **")
print("\t*************************************************************")
print("\n")
print("\t Input the generators fundamental group of your manifold:")
print("\t Write the generators as one string, separated by a comma.")
print("\t For example, if your group is <x1, x2| x1^3=x2^2=x1^(-1)x2=1>,")
print("\t input the string as 'x1,x2' (without quotes). Not robust for")
print("\t inputs differing from these instructions.")
gens = input()
print("\t Now input the quotients of the group presentation. Separate")
print("\t the quotient words by a space. Denote the inverse of a")
print("\t generator by adding a '*' to the end. For the above example,")
print("\t the input would be 'x1,x1,x1 x2,x2 x1*,x2' (without quotes).")
quotients = input()
quotient_list = quotients.split(" ")
print("\t Now input the word of the meridian using the conventions above.")
lInput = input()

os.system('clear')
print("\t Calculating...")
particles = particleTypes(gens, quotient_list, lInput)
printQ = ""
for q in quotient_list:
  for el in q.split(","):
    printQ = printQ + el
  printQ = printQ + "="
printQ = printQ + "1"

os.system('clear')
print("For the fundamental group")
print("<"+gens+"|"+printQ+">,")
print("the particle types are:")
print("\n")

for p in particles:
  print("__________________________________________________________________")
  print("|"+p)
print("__________________________________________________________________")
print("\n")
